// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package utils

import (
	"os"
	"sync"
)

// Ensure, that MockOsProxy does implement OsProxy.
// If this is not the case, regenerate this file with moq.
var _ OsProxy = &MockOsProxy{}

// MockOsProxy is a mock implementation of OsProxy.
//
//	func TestSomethingThatUsesOsProxy(t *testing.T) {
//
//		// make and configure a mocked OsProxy
//		mockedOsProxy := &MockOsProxy{
//			CreateFunc: func(s string) (*os.File, error) {
//				panic("mock out the Create method")
//			},
//			MkdirAllFunc: func(s string, v os.FileMode) error {
//				panic("mock out the MkdirAll method")
//			},
//			ReadFileIfExistsFunc: func(pth string) (string, bool, error) {
//				panic("mock out the ReadFileIfExists method")
//			},
//			RemoveFunc: func(s string) error {
//				panic("mock out the Remove method")
//			},
//			UserHomeDirFunc: func() (string, error) {
//				panic("mock out the UserHomeDir method")
//			},
//			WriteFileFunc: func(s string, bytes []byte, v os.FileMode) error {
//				panic("mock out the WriteFile method")
//			},
//		}
//
//		// use mockedOsProxy in code that requires OsProxy
//		// and then make assertions.
//
//	}
type MockOsProxy struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(s string) (*os.File, error)

	// MkdirAllFunc mocks the MkdirAll method.
	MkdirAllFunc func(s string, v os.FileMode) error

	// ReadFileIfExistsFunc mocks the ReadFileIfExists method.
	ReadFileIfExistsFunc func(pth string) (string, bool, error)

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(s string) error

	// UserHomeDirFunc mocks the UserHomeDir method.
	UserHomeDirFunc func() (string, error)

	// WriteFileFunc mocks the WriteFile method.
	WriteFileFunc func(s string, bytes []byte, v os.FileMode) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// S is the s argument value.
			S string
		}
		// MkdirAll holds details about calls to the MkdirAll method.
		MkdirAll []struct {
			// S is the s argument value.
			S string
			// V is the v argument value.
			V os.FileMode
		}
		// ReadFileIfExists holds details about calls to the ReadFileIfExists method.
		ReadFileIfExists []struct {
			// Pth is the pth argument value.
			Pth string
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// S is the s argument value.
			S string
		}
		// UserHomeDir holds details about calls to the UserHomeDir method.
		UserHomeDir []struct {
		}
		// WriteFile holds details about calls to the WriteFile method.
		WriteFile []struct {
			// S is the s argument value.
			S string
			// Bytes is the bytes argument value.
			Bytes []byte
			// V is the v argument value.
			V os.FileMode
		}
	}
	lockCreate           sync.RWMutex
	lockMkdirAll         sync.RWMutex
	lockReadFileIfExists sync.RWMutex
	lockRemove           sync.RWMutex
	lockUserHomeDir      sync.RWMutex
	lockWriteFile        sync.RWMutex
}

// Create calls CreateFunc.
func (mock *MockOsProxy) Create(s string) (*os.File, error) {
	if mock.CreateFunc == nil {
		panic("MockOsProxy.CreateFunc: method is nil but OsProxy.Create was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(s)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedOsProxy.CreateCalls())
func (mock *MockOsProxy) CreateCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// MkdirAll calls MkdirAllFunc.
func (mock *MockOsProxy) MkdirAll(s string, v os.FileMode) error {
	if mock.MkdirAllFunc == nil {
		panic("MockOsProxy.MkdirAllFunc: method is nil but OsProxy.MkdirAll was just called")
	}
	callInfo := struct {
		S string
		V os.FileMode
	}{
		S: s,
		V: v,
	}
	mock.lockMkdirAll.Lock()
	mock.calls.MkdirAll = append(mock.calls.MkdirAll, callInfo)
	mock.lockMkdirAll.Unlock()
	return mock.MkdirAllFunc(s, v)
}

// MkdirAllCalls gets all the calls that were made to MkdirAll.
// Check the length with:
//
//	len(mockedOsProxy.MkdirAllCalls())
func (mock *MockOsProxy) MkdirAllCalls() []struct {
	S string
	V os.FileMode
} {
	var calls []struct {
		S string
		V os.FileMode
	}
	mock.lockMkdirAll.RLock()
	calls = mock.calls.MkdirAll
	mock.lockMkdirAll.RUnlock()
	return calls
}

// ReadFileIfExists calls ReadFileIfExistsFunc.
func (mock *MockOsProxy) ReadFileIfExists(pth string) (string, bool, error) {
	if mock.ReadFileIfExistsFunc == nil {
		panic("MockOsProxy.ReadFileIfExistsFunc: method is nil but OsProxy.ReadFileIfExists was just called")
	}
	callInfo := struct {
		Pth string
	}{
		Pth: pth,
	}
	mock.lockReadFileIfExists.Lock()
	mock.calls.ReadFileIfExists = append(mock.calls.ReadFileIfExists, callInfo)
	mock.lockReadFileIfExists.Unlock()
	return mock.ReadFileIfExistsFunc(pth)
}

// ReadFileIfExistsCalls gets all the calls that were made to ReadFileIfExists.
// Check the length with:
//
//	len(mockedOsProxy.ReadFileIfExistsCalls())
func (mock *MockOsProxy) ReadFileIfExistsCalls() []struct {
	Pth string
} {
	var calls []struct {
		Pth string
	}
	mock.lockReadFileIfExists.RLock()
	calls = mock.calls.ReadFileIfExists
	mock.lockReadFileIfExists.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *MockOsProxy) Remove(s string) error {
	if mock.RemoveFunc == nil {
		panic("MockOsProxy.RemoveFunc: method is nil but OsProxy.Remove was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	return mock.RemoveFunc(s)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedOsProxy.RemoveCalls())
func (mock *MockOsProxy) RemoveCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// UserHomeDir calls UserHomeDirFunc.
func (mock *MockOsProxy) UserHomeDir() (string, error) {
	if mock.UserHomeDirFunc == nil {
		panic("MockOsProxy.UserHomeDirFunc: method is nil but OsProxy.UserHomeDir was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUserHomeDir.Lock()
	mock.calls.UserHomeDir = append(mock.calls.UserHomeDir, callInfo)
	mock.lockUserHomeDir.Unlock()
	return mock.UserHomeDirFunc()
}

// UserHomeDirCalls gets all the calls that were made to UserHomeDir.
// Check the length with:
//
//	len(mockedOsProxy.UserHomeDirCalls())
func (mock *MockOsProxy) UserHomeDirCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUserHomeDir.RLock()
	calls = mock.calls.UserHomeDir
	mock.lockUserHomeDir.RUnlock()
	return calls
}

// WriteFile calls WriteFileFunc.
func (mock *MockOsProxy) WriteFile(s string, bytes []byte, v os.FileMode) error {
	if mock.WriteFileFunc == nil {
		panic("MockOsProxy.WriteFileFunc: method is nil but OsProxy.WriteFile was just called")
	}
	callInfo := struct {
		S     string
		Bytes []byte
		V     os.FileMode
	}{
		S:     s,
		Bytes: bytes,
		V:     v,
	}
	mock.lockWriteFile.Lock()
	mock.calls.WriteFile = append(mock.calls.WriteFile, callInfo)
	mock.lockWriteFile.Unlock()
	return mock.WriteFileFunc(s, bytes, v)
}

// WriteFileCalls gets all the calls that were made to WriteFile.
// Check the length with:
//
//	len(mockedOsProxy.WriteFileCalls())
func (mock *MockOsProxy) WriteFileCalls() []struct {
	S     string
	Bytes []byte
	V     os.FileMode
} {
	var calls []struct {
		S     string
		Bytes []byte
		V     os.FileMode
	}
	mock.lockWriteFile.RLock()
	calls = mock.calls.WriteFile
	mock.lockWriteFile.RUnlock()
	return calls
}
