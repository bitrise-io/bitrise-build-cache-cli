// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package utils

import (
	"io"
	"os"
	"sync"
)

// Ensure, that MockEncoder does implement Encoder.
// If this is not the case, regenerate this file with moq.
var _ Encoder = &MockEncoder{}

// MockEncoder is a mock implementation of Encoder.
//
//	func TestSomethingThatUsesEncoder(t *testing.T) {
//
//		// make and configure a mocked Encoder
//		mockedEncoder := &MockEncoder{
//			EncodeFunc: func(data any) error {
//				panic("mock out the Encode method")
//			},
//			SetEscapeHTMLFunc: func(escape bool)  {
//				panic("mock out the SetEscapeHTML method")
//			},
//			SetIndentFunc: func(prefix string, indent string)  {
//				panic("mock out the SetIndent method")
//			},
//		}
//
//		// use mockedEncoder in code that requires Encoder
//		// and then make assertions.
//
//	}
type MockEncoder struct {
	// EncodeFunc mocks the Encode method.
	EncodeFunc func(data any) error

	// SetEscapeHTMLFunc mocks the SetEscapeHTML method.
	SetEscapeHTMLFunc func(escape bool)

	// SetIndentFunc mocks the SetIndent method.
	SetIndentFunc func(prefix string, indent string)

	// calls tracks calls to the methods.
	calls struct {
		// Encode holds details about calls to the Encode method.
		Encode []struct {
			// Data is the data argument value.
			Data any
		}
		// SetEscapeHTML holds details about calls to the SetEscapeHTML method.
		SetEscapeHTML []struct {
			// Escape is the escape argument value.
			Escape bool
		}
		// SetIndent holds details about calls to the SetIndent method.
		SetIndent []struct {
			// Prefix is the prefix argument value.
			Prefix string
			// Indent is the indent argument value.
			Indent string
		}
	}
	lockEncode        sync.RWMutex
	lockSetEscapeHTML sync.RWMutex
	lockSetIndent     sync.RWMutex
}

// Encode calls EncodeFunc.
func (mock *MockEncoder) Encode(data any) error {
	if mock.EncodeFunc == nil {
		panic("MockEncoder.EncodeFunc: method is nil but Encoder.Encode was just called")
	}
	callInfo := struct {
		Data any
	}{
		Data: data,
	}
	mock.lockEncode.Lock()
	mock.calls.Encode = append(mock.calls.Encode, callInfo)
	mock.lockEncode.Unlock()
	return mock.EncodeFunc(data)
}

// EncodeCalls gets all the calls that were made to Encode.
// Check the length with:
//
//	len(mockedEncoder.EncodeCalls())
func (mock *MockEncoder) EncodeCalls() []struct {
	Data any
} {
	var calls []struct {
		Data any
	}
	mock.lockEncode.RLock()
	calls = mock.calls.Encode
	mock.lockEncode.RUnlock()
	return calls
}

// SetEscapeHTML calls SetEscapeHTMLFunc.
func (mock *MockEncoder) SetEscapeHTML(escape bool) {
	if mock.SetEscapeHTMLFunc == nil {
		panic("MockEncoder.SetEscapeHTMLFunc: method is nil but Encoder.SetEscapeHTML was just called")
	}
	callInfo := struct {
		Escape bool
	}{
		Escape: escape,
	}
	mock.lockSetEscapeHTML.Lock()
	mock.calls.SetEscapeHTML = append(mock.calls.SetEscapeHTML, callInfo)
	mock.lockSetEscapeHTML.Unlock()
	mock.SetEscapeHTMLFunc(escape)
}

// SetEscapeHTMLCalls gets all the calls that were made to SetEscapeHTML.
// Check the length with:
//
//	len(mockedEncoder.SetEscapeHTMLCalls())
func (mock *MockEncoder) SetEscapeHTMLCalls() []struct {
	Escape bool
} {
	var calls []struct {
		Escape bool
	}
	mock.lockSetEscapeHTML.RLock()
	calls = mock.calls.SetEscapeHTML
	mock.lockSetEscapeHTML.RUnlock()
	return calls
}

// SetIndent calls SetIndentFunc.
func (mock *MockEncoder) SetIndent(prefix string, indent string) {
	if mock.SetIndentFunc == nil {
		panic("MockEncoder.SetIndentFunc: method is nil but Encoder.SetIndent was just called")
	}
	callInfo := struct {
		Prefix string
		Indent string
	}{
		Prefix: prefix,
		Indent: indent,
	}
	mock.lockSetIndent.Lock()
	mock.calls.SetIndent = append(mock.calls.SetIndent, callInfo)
	mock.lockSetIndent.Unlock()
	mock.SetIndentFunc(prefix, indent)
}

// SetIndentCalls gets all the calls that were made to SetIndent.
// Check the length with:
//
//	len(mockedEncoder.SetIndentCalls())
func (mock *MockEncoder) SetIndentCalls() []struct {
	Prefix string
	Indent string
} {
	var calls []struct {
		Prefix string
		Indent string
	}
	mock.lockSetIndent.RLock()
	calls = mock.calls.SetIndent
	mock.lockSetIndent.RUnlock()
	return calls
}

// Ensure, that MockEncoderFactory does implement EncoderFactory.
// If this is not the case, regenerate this file with moq.
var _ EncoderFactory = &MockEncoderFactory{}

// MockEncoderFactory is a mock implementation of EncoderFactory.
//
//	func TestSomethingThatUsesEncoderFactory(t *testing.T) {
//
//		// make and configure a mocked EncoderFactory
//		mockedEncoderFactory := &MockEncoderFactory{
//			EncoderFunc: func(v io.Writer) Encoder {
//				panic("mock out the Encoder method")
//			},
//		}
//
//		// use mockedEncoderFactory in code that requires EncoderFactory
//		// and then make assertions.
//
//	}
type MockEncoderFactory struct {
	// EncoderFunc mocks the Encoder method.
	EncoderFunc func(v io.Writer) Encoder

	// calls tracks calls to the methods.
	calls struct {
		// Encoder holds details about calls to the Encoder method.
		Encoder []struct {
			// V is the v argument value.
			V io.Writer
		}
	}
	lockEncoder sync.RWMutex
}

// Encoder calls EncoderFunc.
func (mock *MockEncoderFactory) Encoder(v io.Writer) Encoder {
	if mock.EncoderFunc == nil {
		panic("MockEncoderFactory.EncoderFunc: method is nil but EncoderFactory.Encoder was just called")
	}
	callInfo := struct {
		V io.Writer
	}{
		V: v,
	}
	mock.lockEncoder.Lock()
	mock.calls.Encoder = append(mock.calls.Encoder, callInfo)
	mock.lockEncoder.Unlock()
	return mock.EncoderFunc(v)
}

// EncoderCalls gets all the calls that were made to Encoder.
// Check the length with:
//
//	len(mockedEncoderFactory.EncoderCalls())
func (mock *MockEncoderFactory) EncoderCalls() []struct {
	V io.Writer
} {
	var calls []struct {
		V io.Writer
	}
	mock.lockEncoder.RLock()
	calls = mock.calls.Encoder
	mock.lockEncoder.RUnlock()
	return calls
}

// Ensure, that MockOsProxy does implement OsProxy.
// If this is not the case, regenerate this file with moq.
var _ OsProxy = &MockOsProxy{}

// MockOsProxy is a mock implementation of OsProxy.
//
//	func TestSomethingThatUsesOsProxy(t *testing.T) {
//
//		// make and configure a mocked OsProxy
//		mockedOsProxy := &MockOsProxy{
//			CreateFunc: func(s string) (*os.File, error) {
//				panic("mock out the Create method")
//			},
//			MkdirAllFunc: func(s string, v os.FileMode) error {
//				panic("mock out the MkdirAll method")
//			},
//			ReadFileIfExistsFunc: func(pth string) (string, bool, error) {
//				panic("mock out the ReadFileIfExists method")
//			},
//			UserHomeDirFunc: func() (string, error) {
//				panic("mock out the UserHomeDir method")
//			},
//			WriteFileFunc: func(s string, bytes []byte, v os.FileMode) error {
//				panic("mock out the WriteFile method")
//			},
//		}
//
//		// use mockedOsProxy in code that requires OsProxy
//		// and then make assertions.
//
//	}
type MockOsProxy struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(s string) (*os.File, error)

	// MkdirAllFunc mocks the MkdirAll method.
	MkdirAllFunc func(s string, v os.FileMode) error

	// ReadFileIfExistsFunc mocks the ReadFileIfExists method.
	ReadFileIfExistsFunc func(pth string) (string, bool, error)

	// UserHomeDirFunc mocks the UserHomeDir method.
	UserHomeDirFunc func() (string, error)

	// WriteFileFunc mocks the WriteFile method.
	WriteFileFunc func(s string, bytes []byte, v os.FileMode) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// S is the s argument value.
			S string
		}
		// MkdirAll holds details about calls to the MkdirAll method.
		MkdirAll []struct {
			// S is the s argument value.
			S string
			// V is the v argument value.
			V os.FileMode
		}
		// ReadFileIfExists holds details about calls to the ReadFileIfExists method.
		ReadFileIfExists []struct {
			// Pth is the pth argument value.
			Pth string
		}
		// UserHomeDir holds details about calls to the UserHomeDir method.
		UserHomeDir []struct {
		}
		// WriteFile holds details about calls to the WriteFile method.
		WriteFile []struct {
			// S is the s argument value.
			S string
			// Bytes is the bytes argument value.
			Bytes []byte
			// V is the v argument value.
			V os.FileMode
		}
	}
	lockCreate           sync.RWMutex
	lockMkdirAll         sync.RWMutex
	lockReadFileIfExists sync.RWMutex
	lockUserHomeDir      sync.RWMutex
	lockWriteFile        sync.RWMutex
}

// Create calls CreateFunc.
func (mock *MockOsProxy) Create(s string) (*os.File, error) {
	if mock.CreateFunc == nil {
		panic("MockOsProxy.CreateFunc: method is nil but OsProxy.Create was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(s)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedOsProxy.CreateCalls())
func (mock *MockOsProxy) CreateCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// MkdirAll calls MkdirAllFunc.
func (mock *MockOsProxy) MkdirAll(s string, v os.FileMode) error {
	if mock.MkdirAllFunc == nil {
		panic("MockOsProxy.MkdirAllFunc: method is nil but OsProxy.MkdirAll was just called")
	}
	callInfo := struct {
		S string
		V os.FileMode
	}{
		S: s,
		V: v,
	}
	mock.lockMkdirAll.Lock()
	mock.calls.MkdirAll = append(mock.calls.MkdirAll, callInfo)
	mock.lockMkdirAll.Unlock()
	return mock.MkdirAllFunc(s, v)
}

// MkdirAllCalls gets all the calls that were made to MkdirAll.
// Check the length with:
//
//	len(mockedOsProxy.MkdirAllCalls())
func (mock *MockOsProxy) MkdirAllCalls() []struct {
	S string
	V os.FileMode
} {
	var calls []struct {
		S string
		V os.FileMode
	}
	mock.lockMkdirAll.RLock()
	calls = mock.calls.MkdirAll
	mock.lockMkdirAll.RUnlock()
	return calls
}

// ReadFileIfExists calls ReadFileIfExistsFunc.
func (mock *MockOsProxy) ReadFileIfExists(pth string) (string, bool, error) {
	if mock.ReadFileIfExistsFunc == nil {
		panic("MockOsProxy.ReadFileIfExistsFunc: method is nil but OsProxy.ReadFileIfExists was just called")
	}
	callInfo := struct {
		Pth string
	}{
		Pth: pth,
	}
	mock.lockReadFileIfExists.Lock()
	mock.calls.ReadFileIfExists = append(mock.calls.ReadFileIfExists, callInfo)
	mock.lockReadFileIfExists.Unlock()
	return mock.ReadFileIfExistsFunc(pth)
}

// ReadFileIfExistsCalls gets all the calls that were made to ReadFileIfExists.
// Check the length with:
//
//	len(mockedOsProxy.ReadFileIfExistsCalls())
func (mock *MockOsProxy) ReadFileIfExistsCalls() []struct {
	Pth string
} {
	var calls []struct {
		Pth string
	}
	mock.lockReadFileIfExists.RLock()
	calls = mock.calls.ReadFileIfExists
	mock.lockReadFileIfExists.RUnlock()
	return calls
}

// UserHomeDir calls UserHomeDirFunc.
func (mock *MockOsProxy) UserHomeDir() (string, error) {
	if mock.UserHomeDirFunc == nil {
		panic("MockOsProxy.UserHomeDirFunc: method is nil but OsProxy.UserHomeDir was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUserHomeDir.Lock()
	mock.calls.UserHomeDir = append(mock.calls.UserHomeDir, callInfo)
	mock.lockUserHomeDir.Unlock()
	return mock.UserHomeDirFunc()
}

// UserHomeDirCalls gets all the calls that were made to UserHomeDir.
// Check the length with:
//
//	len(mockedOsProxy.UserHomeDirCalls())
func (mock *MockOsProxy) UserHomeDirCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUserHomeDir.RLock()
	calls = mock.calls.UserHomeDir
	mock.lockUserHomeDir.RUnlock()
	return calls
}

// WriteFile calls WriteFileFunc.
func (mock *MockOsProxy) WriteFile(s string, bytes []byte, v os.FileMode) error {
	if mock.WriteFileFunc == nil {
		panic("MockOsProxy.WriteFileFunc: method is nil but OsProxy.WriteFile was just called")
	}
	callInfo := struct {
		S     string
		Bytes []byte
		V     os.FileMode
	}{
		S:     s,
		Bytes: bytes,
		V:     v,
	}
	mock.lockWriteFile.Lock()
	mock.calls.WriteFile = append(mock.calls.WriteFile, callInfo)
	mock.lockWriteFile.Unlock()
	return mock.WriteFileFunc(s, bytes, v)
}

// WriteFileCalls gets all the calls that were made to WriteFile.
// Check the length with:
//
//	len(mockedOsProxy.WriteFileCalls())
func (mock *MockOsProxy) WriteFileCalls() []struct {
	S     string
	Bytes []byte
	V     os.FileMode
} {
	var calls []struct {
		S     string
		Bytes []byte
		V     os.FileMode
	}
	mock.lockWriteFile.RLock()
	calls = mock.calls.WriteFile
	mock.lockWriteFile.RUnlock()
	return calls
}
