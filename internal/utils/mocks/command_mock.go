// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/bitrise-io/bitrise-build-cache-cli/internal/utils"
	"os"
	"sync"
	"syscall"
)

// Ensure, that CommandMock does implement utils.Command.
// If this is not the case, regenerate this file with moq.
var _ utils.Command = &CommandMock{}

// CommandMock is a mock implementation of utils.Command.
//
//	func TestSomethingThatUsesCommand(t *testing.T) {
//
//		// make and configure a mocked utils.Command
//		mockedCommand := &CommandMock{
//			CombinedOutputFunc: func() ([]byte, error) {
//				panic("mock out the CombinedOutput method")
//			},
//			ErrFunc: func() error {
//				panic("mock out the Err method")
//			},
//			PIDFunc: func() int {
//				panic("mock out the PID method")
//			},
//			SetStderrFunc: func(file *os.File)  {
//				panic("mock out the SetStderr method")
//			},
//			SetStdinFunc: func(file *os.File)  {
//				panic("mock out the SetStdin method")
//			},
//			SetStdoutFunc: func(file *os.File)  {
//				panic("mock out the SetStdout method")
//			},
//			SetSysProcAttrFunc: func(sysProcAttr *syscall.SysProcAttr)  {
//				panic("mock out the SetSysProcAttr method")
//			},
//			StartFunc: func() error {
//				panic("mock out the Start method")
//			},
//			WaitFunc: func() error {
//				panic("mock out the Wait method")
//			},
//		}
//
//		// use mockedCommand in code that requires utils.Command
//		// and then make assertions.
//
//	}
type CommandMock struct {
	// CombinedOutputFunc mocks the CombinedOutput method.
	CombinedOutputFunc func() ([]byte, error)

	// ErrFunc mocks the Err method.
	ErrFunc func() error

	// PIDFunc mocks the PID method.
	PIDFunc func() int

	// SetStderrFunc mocks the SetStderr method.
	SetStderrFunc func(file *os.File)

	// SetStdinFunc mocks the SetStdin method.
	SetStdinFunc func(file *os.File)

	// SetStdoutFunc mocks the SetStdout method.
	SetStdoutFunc func(file *os.File)

	// SetSysProcAttrFunc mocks the SetSysProcAttr method.
	SetSysProcAttrFunc func(sysProcAttr *syscall.SysProcAttr)

	// StartFunc mocks the Start method.
	StartFunc func() error

	// WaitFunc mocks the Wait method.
	WaitFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// CombinedOutput holds details about calls to the CombinedOutput method.
		CombinedOutput []struct {
		}
		// Err holds details about calls to the Err method.
		Err []struct {
		}
		// PID holds details about calls to the PID method.
		PID []struct {
		}
		// SetStderr holds details about calls to the SetStderr method.
		SetStderr []struct {
			// File is the file argument value.
			File *os.File
		}
		// SetStdin holds details about calls to the SetStdin method.
		SetStdin []struct {
			// File is the file argument value.
			File *os.File
		}
		// SetStdout holds details about calls to the SetStdout method.
		SetStdout []struct {
			// File is the file argument value.
			File *os.File
		}
		// SetSysProcAttr holds details about calls to the SetSysProcAttr method.
		SetSysProcAttr []struct {
			// SysProcAttr is the sysProcAttr argument value.
			SysProcAttr *syscall.SysProcAttr
		}
		// Start holds details about calls to the Start method.
		Start []struct {
		}
		// Wait holds details about calls to the Wait method.
		Wait []struct {
		}
	}
	lockCombinedOutput sync.RWMutex
	lockErr            sync.RWMutex
	lockPID            sync.RWMutex
	lockSetStderr      sync.RWMutex
	lockSetStdin       sync.RWMutex
	lockSetStdout      sync.RWMutex
	lockSetSysProcAttr sync.RWMutex
	lockStart          sync.RWMutex
	lockWait           sync.RWMutex
}

// CombinedOutput calls CombinedOutputFunc.
func (mock *CommandMock) CombinedOutput() ([]byte, error) {
	callInfo := struct {
	}{}
	mock.lockCombinedOutput.Lock()
	mock.calls.CombinedOutput = append(mock.calls.CombinedOutput, callInfo)
	mock.lockCombinedOutput.Unlock()
	if mock.CombinedOutputFunc == nil {
		var (
			bytesOut []byte
			errOut   error
		)
		return bytesOut, errOut
	}
	return mock.CombinedOutputFunc()
}

// CombinedOutputCalls gets all the calls that were made to CombinedOutput.
// Check the length with:
//
//	len(mockedCommand.CombinedOutputCalls())
func (mock *CommandMock) CombinedOutputCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCombinedOutput.RLock()
	calls = mock.calls.CombinedOutput
	mock.lockCombinedOutput.RUnlock()
	return calls
}

// Err calls ErrFunc.
func (mock *CommandMock) Err() error {
	callInfo := struct {
	}{}
	mock.lockErr.Lock()
	mock.calls.Err = append(mock.calls.Err, callInfo)
	mock.lockErr.Unlock()
	if mock.ErrFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.ErrFunc()
}

// ErrCalls gets all the calls that were made to Err.
// Check the length with:
//
//	len(mockedCommand.ErrCalls())
func (mock *CommandMock) ErrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockErr.RLock()
	calls = mock.calls.Err
	mock.lockErr.RUnlock()
	return calls
}

// PID calls PIDFunc.
func (mock *CommandMock) PID() int {
	callInfo := struct {
	}{}
	mock.lockPID.Lock()
	mock.calls.PID = append(mock.calls.PID, callInfo)
	mock.lockPID.Unlock()
	if mock.PIDFunc == nil {
		var (
			nOut int
		)
		return nOut
	}
	return mock.PIDFunc()
}

// PIDCalls gets all the calls that were made to PID.
// Check the length with:
//
//	len(mockedCommand.PIDCalls())
func (mock *CommandMock) PIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPID.RLock()
	calls = mock.calls.PID
	mock.lockPID.RUnlock()
	return calls
}

// SetStderr calls SetStderrFunc.
func (mock *CommandMock) SetStderr(file *os.File) {
	callInfo := struct {
		File *os.File
	}{
		File: file,
	}
	mock.lockSetStderr.Lock()
	mock.calls.SetStderr = append(mock.calls.SetStderr, callInfo)
	mock.lockSetStderr.Unlock()
	if mock.SetStderrFunc == nil {
		return
	}
	mock.SetStderrFunc(file)
}

// SetStderrCalls gets all the calls that were made to SetStderr.
// Check the length with:
//
//	len(mockedCommand.SetStderrCalls())
func (mock *CommandMock) SetStderrCalls() []struct {
	File *os.File
} {
	var calls []struct {
		File *os.File
	}
	mock.lockSetStderr.RLock()
	calls = mock.calls.SetStderr
	mock.lockSetStderr.RUnlock()
	return calls
}

// SetStdin calls SetStdinFunc.
func (mock *CommandMock) SetStdin(file *os.File) {
	callInfo := struct {
		File *os.File
	}{
		File: file,
	}
	mock.lockSetStdin.Lock()
	mock.calls.SetStdin = append(mock.calls.SetStdin, callInfo)
	mock.lockSetStdin.Unlock()
	if mock.SetStdinFunc == nil {
		return
	}
	mock.SetStdinFunc(file)
}

// SetStdinCalls gets all the calls that were made to SetStdin.
// Check the length with:
//
//	len(mockedCommand.SetStdinCalls())
func (mock *CommandMock) SetStdinCalls() []struct {
	File *os.File
} {
	var calls []struct {
		File *os.File
	}
	mock.lockSetStdin.RLock()
	calls = mock.calls.SetStdin
	mock.lockSetStdin.RUnlock()
	return calls
}

// SetStdout calls SetStdoutFunc.
func (mock *CommandMock) SetStdout(file *os.File) {
	callInfo := struct {
		File *os.File
	}{
		File: file,
	}
	mock.lockSetStdout.Lock()
	mock.calls.SetStdout = append(mock.calls.SetStdout, callInfo)
	mock.lockSetStdout.Unlock()
	if mock.SetStdoutFunc == nil {
		return
	}
	mock.SetStdoutFunc(file)
}

// SetStdoutCalls gets all the calls that were made to SetStdout.
// Check the length with:
//
//	len(mockedCommand.SetStdoutCalls())
func (mock *CommandMock) SetStdoutCalls() []struct {
	File *os.File
} {
	var calls []struct {
		File *os.File
	}
	mock.lockSetStdout.RLock()
	calls = mock.calls.SetStdout
	mock.lockSetStdout.RUnlock()
	return calls
}

// SetSysProcAttr calls SetSysProcAttrFunc.
func (mock *CommandMock) SetSysProcAttr(sysProcAttr *syscall.SysProcAttr) {
	callInfo := struct {
		SysProcAttr *syscall.SysProcAttr
	}{
		SysProcAttr: sysProcAttr,
	}
	mock.lockSetSysProcAttr.Lock()
	mock.calls.SetSysProcAttr = append(mock.calls.SetSysProcAttr, callInfo)
	mock.lockSetSysProcAttr.Unlock()
	if mock.SetSysProcAttrFunc == nil {
		return
	}
	mock.SetSysProcAttrFunc(sysProcAttr)
}

// SetSysProcAttrCalls gets all the calls that were made to SetSysProcAttr.
// Check the length with:
//
//	len(mockedCommand.SetSysProcAttrCalls())
func (mock *CommandMock) SetSysProcAttrCalls() []struct {
	SysProcAttr *syscall.SysProcAttr
} {
	var calls []struct {
		SysProcAttr *syscall.SysProcAttr
	}
	mock.lockSetSysProcAttr.RLock()
	calls = mock.calls.SetSysProcAttr
	mock.lockSetSysProcAttr.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *CommandMock) Start() error {
	callInfo := struct {
	}{}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	if mock.StartFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.StartFunc()
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedCommand.StartCalls())
func (mock *CommandMock) StartCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Wait calls WaitFunc.
func (mock *CommandMock) Wait() error {
	callInfo := struct {
	}{}
	mock.lockWait.Lock()
	mock.calls.Wait = append(mock.calls.Wait, callInfo)
	mock.lockWait.Unlock()
	if mock.WaitFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.WaitFunc()
}

// WaitCalls gets all the calls that were made to Wait.
// Check the length with:
//
//	len(mockedCommand.WaitCalls())
func (mock *CommandMock) WaitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockWait.RLock()
	calls = mock.calls.Wait
	mock.lockWait.RUnlock()
	return calls
}
