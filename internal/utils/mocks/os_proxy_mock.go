// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"os"
	"sync"

	"github.com/bitrise-io/bitrise-build-cache-cli/internal/utils"
)

// Ensure, that OsProxyMock does implement utils.OsProxy.
// If this is not the case, regenerate this file with moq.
var _ utils.OsProxy = &OsProxyMock{}

// OsProxyMock is a mock implementation of utils.OsProxy.
//
//	func TestSomethingThatUsesOsProxy(t *testing.T) {
//
//		// make and configure a mocked utils.OsProxy
//		mockedOsProxy := &OsProxyMock{
//			CreateFunc: func(pth string) (*os.File, error) {
//				panic("mock out the Create method")
//			},
//			MkdirAllFunc: func(pth string, mode os.FileMode) error {
//				panic("mock out the MkdirAll method")
//			},
//			ReadFileIfExistsFunc: func(pth string) (string, bool, error) {
//				panic("mock out the ReadFileIfExists method")
//			},
//			UserHomeDirFunc: func() (string, error) {
//				panic("mock out the UserHomeDir method")
//			},
//			WriteFileFunc: func(pth string, data []byte, mode os.FileMode) error {
//				panic("mock out the WriteFile method")
//			},
//		}
//
//		// use mockedOsProxy in code that requires utils.OsProxy
//		// and then make assertions.
//
//	}
type OsProxyMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(pth string) (*os.File, error)

	// MkdirAllFunc mocks the MkdirAll method.
	MkdirAllFunc func(pth string, mode os.FileMode) error

	// ReadFileIfExistsFunc mocks the ReadFileIfExists method.
	ReadFileIfExistsFunc func(pth string) (string, bool, error)

	// UserHomeDirFunc mocks the UserHomeDir method.
	UserHomeDirFunc func() (string, error)

	// WriteFileFunc mocks the WriteFile method.
	WriteFileFunc func(pth string, data []byte, mode os.FileMode) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Pth is the pth argument value.
			Pth string
		}
		// MkdirAll holds details about calls to the MkdirAll method.
		MkdirAll []struct {
			// Pth is the pth argument value.
			Pth string
			// Mode is the mode argument value.
			Mode os.FileMode
		}
		// ReadFileIfExists holds details about calls to the ReadFileIfExists method.
		ReadFileIfExists []struct {
			// Pth is the pth argument value.
			Pth string
		}
		// UserHomeDir holds details about calls to the UserHomeDir method.
		UserHomeDir []struct {
		}
		// WriteFile holds details about calls to the WriteFile method.
		WriteFile []struct {
			// Pth is the pth argument value.
			Pth string
			// Data is the data argument value.
			Data []byte
			// Mode is the mode argument value.
			Mode os.FileMode
		}
	}
	lockCreate           sync.RWMutex
	lockMkdirAll         sync.RWMutex
	lockReadFileIfExists sync.RWMutex
	lockUserHomeDir      sync.RWMutex
	lockWriteFile        sync.RWMutex
}

// Create calls CreateFunc.
func (mock *OsProxyMock) Create(pth string) (*os.File, error) {
	if mock.CreateFunc == nil {
		panic("OsProxyMock.CreateFunc: method is nil but OsProxy.Create was just called")
	}
	callInfo := struct {
		Pth string
	}{
		Pth: pth,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(pth)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedOsProxy.CreateCalls())
func (mock *OsProxyMock) CreateCalls() []struct {
	Pth string
} {
	var calls []struct {
		Pth string
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// MkdirAll calls MkdirAllFunc.
func (mock *OsProxyMock) MkdirAll(pth string, mode os.FileMode) error {
	if mock.MkdirAllFunc == nil {
		panic("OsProxyMock.MkdirAllFunc: method is nil but OsProxy.MkdirAll was just called")
	}
	callInfo := struct {
		Pth  string
		Mode os.FileMode
	}{
		Pth:  pth,
		Mode: mode,
	}
	mock.lockMkdirAll.Lock()
	mock.calls.MkdirAll = append(mock.calls.MkdirAll, callInfo)
	mock.lockMkdirAll.Unlock()
	return mock.MkdirAllFunc(pth, mode)
}

// MkdirAllCalls gets all the calls that were made to MkdirAll.
// Check the length with:
//
//	len(mockedOsProxy.MkdirAllCalls())
func (mock *OsProxyMock) MkdirAllCalls() []struct {
	Pth  string
	Mode os.FileMode
} {
	var calls []struct {
		Pth  string
		Mode os.FileMode
	}
	mock.lockMkdirAll.RLock()
	calls = mock.calls.MkdirAll
	mock.lockMkdirAll.RUnlock()
	return calls
}

// ReadFileIfExists calls ReadFileIfExistsFunc.
func (mock *OsProxyMock) ReadFileIfExists(pth string) (string, bool, error) {
	if mock.ReadFileIfExistsFunc == nil {
		panic("OsProxyMock.ReadFileIfExistsFunc: method is nil but OsProxy.ReadFileIfExists was just called")
	}
	callInfo := struct {
		Pth string
	}{
		Pth: pth,
	}
	mock.lockReadFileIfExists.Lock()
	mock.calls.ReadFileIfExists = append(mock.calls.ReadFileIfExists, callInfo)
	mock.lockReadFileIfExists.Unlock()
	return mock.ReadFileIfExistsFunc(pth)
}

// ReadFileIfExistsCalls gets all the calls that were made to ReadFileIfExists.
// Check the length with:
//
//	len(mockedOsProxy.ReadFileIfExistsCalls())
func (mock *OsProxyMock) ReadFileIfExistsCalls() []struct {
	Pth string
} {
	var calls []struct {
		Pth string
	}
	mock.lockReadFileIfExists.RLock()
	calls = mock.calls.ReadFileIfExists
	mock.lockReadFileIfExists.RUnlock()
	return calls
}

// UserHomeDir calls UserHomeDirFunc.
func (mock *OsProxyMock) UserHomeDir() (string, error) {
	if mock.UserHomeDirFunc == nil {
		panic("OsProxyMock.UserHomeDirFunc: method is nil but OsProxy.UserHomeDir was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUserHomeDir.Lock()
	mock.calls.UserHomeDir = append(mock.calls.UserHomeDir, callInfo)
	mock.lockUserHomeDir.Unlock()
	return mock.UserHomeDirFunc()
}

// UserHomeDirCalls gets all the calls that were made to UserHomeDir.
// Check the length with:
//
//	len(mockedOsProxy.UserHomeDirCalls())
func (mock *OsProxyMock) UserHomeDirCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUserHomeDir.RLock()
	calls = mock.calls.UserHomeDir
	mock.lockUserHomeDir.RUnlock()
	return calls
}

// WriteFile calls WriteFileFunc.
func (mock *OsProxyMock) WriteFile(pth string, data []byte, mode os.FileMode) error {
	if mock.WriteFileFunc == nil {
		panic("OsProxyMock.WriteFileFunc: method is nil but OsProxy.WriteFile was just called")
	}
	callInfo := struct {
		Pth  string
		Data []byte
		Mode os.FileMode
	}{
		Pth:  pth,
		Data: data,
		Mode: mode,
	}
	mock.lockWriteFile.Lock()
	mock.calls.WriteFile = append(mock.calls.WriteFile, callInfo)
	mock.lockWriteFile.Unlock()
	return mock.WriteFileFunc(pth, data, mode)
}

// WriteFileCalls gets all the calls that were made to WriteFile.
// Check the length with:
//
//	len(mockedOsProxy.WriteFileCalls())
func (mock *OsProxyMock) WriteFileCalls() []struct {
	Pth  string
	Data []byte
	Mode os.FileMode
} {
	var calls []struct {
		Pth  string
		Data []byte
		Mode os.FileMode
	}
	mock.lockWriteFile.RLock()
	calls = mock.calls.WriteFile
	mock.lockWriteFile.RUnlock()
	return calls
}
