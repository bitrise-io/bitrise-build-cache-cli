// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/bitrise-io/bitrise-build-cache-cli/internal/utils"
	"os"
	"sync"
)

// Ensure, that OsProxyMock does implement utils.OsProxy.
// If this is not the case, regenerate this file with moq.
var _ utils.OsProxy = &OsProxyMock{}

// OsProxyMock is a mock implementation of utils.OsProxy.
//
//	func TestSomethingThatUsesOsProxy(t *testing.T) {
//
//		// make and configure a mocked utils.OsProxy
//		mockedOsProxy := &OsProxyMock{
//			CreateFunc: func(name string) (*os.File, error) {
//				panic("mock out the Create method")
//			},
//			ExecutableFunc: func() (string, error) {
//				panic("mock out the Executable method")
//			},
//			GetwdFunc: func() (string, error) {
//				panic("mock out the Getwd method")
//			},
//			HostnameFunc: func() (string, error) {
//				panic("mock out the Hostname method")
//			},
//			MkdirAllFunc: func(name string, mode os.FileMode) error {
//				panic("mock out the MkdirAll method")
//			},
//			OpenFileFunc: func(name string, flag int, perm os.FileMode) (*os.File, error) {
//				panic("mock out the OpenFile method")
//			},
//			ReadFileIfExistsFunc: func(name string) (string, bool, error) {
//				panic("mock out the ReadFileIfExists method")
//			},
//			RemoveFunc: func(name string) error {
//				panic("mock out the Remove method")
//			},
//			StatFunc: func(pth string) (os.FileInfo, error) {
//				panic("mock out the Stat method")
//			},
//			TempDirFunc: func() string {
//				panic("mock out the TempDir method")
//			},
//			UserHomeDirFunc: func() (string, error) {
//				panic("mock out the UserHomeDir method")
//			},
//			WriteFileFunc: func(name string, data []byte, mode os.FileMode) error {
//				panic("mock out the WriteFile method")
//			},
//		}
//
//		// use mockedOsProxy in code that requires utils.OsProxy
//		// and then make assertions.
//
//	}
type OsProxyMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(name string) (*os.File, error)

	// ExecutableFunc mocks the Executable method.
	ExecutableFunc func() (string, error)

	// GetwdFunc mocks the Getwd method.
	GetwdFunc func() (string, error)

	// HostnameFunc mocks the Hostname method.
	HostnameFunc func() (string, error)

	// MkdirAllFunc mocks the MkdirAll method.
	MkdirAllFunc func(name string, mode os.FileMode) error

	// OpenFileFunc mocks the OpenFile method.
	OpenFileFunc func(name string, flag int, perm os.FileMode) (*os.File, error)

	// ReadFileIfExistsFunc mocks the ReadFileIfExists method.
	ReadFileIfExistsFunc func(name string) (string, bool, error)

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(name string) error

	// StatFunc mocks the Stat method.
	StatFunc func(pth string) (os.FileInfo, error)

	// TempDirFunc mocks the TempDir method.
	TempDirFunc func() string

	// UserHomeDirFunc mocks the UserHomeDir method.
	UserHomeDirFunc func() (string, error)

	// WriteFileFunc mocks the WriteFile method.
	WriteFileFunc func(name string, data []byte, mode os.FileMode) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Name is the name argument value.
			Name string
		}
		// Executable holds details about calls to the Executable method.
		Executable []struct {
		}
		// Getwd holds details about calls to the Getwd method.
		Getwd []struct {
		}
		// Hostname holds details about calls to the Hostname method.
		Hostname []struct {
		}
		// MkdirAll holds details about calls to the MkdirAll method.
		MkdirAll []struct {
			// Name is the name argument value.
			Name string
			// Mode is the mode argument value.
			Mode os.FileMode
		}
		// OpenFile holds details about calls to the OpenFile method.
		OpenFile []struct {
			// Name is the name argument value.
			Name string
			// Flag is the flag argument value.
			Flag int
			// Perm is the perm argument value.
			Perm os.FileMode
		}
		// ReadFileIfExists holds details about calls to the ReadFileIfExists method.
		ReadFileIfExists []struct {
			// Name is the name argument value.
			Name string
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Name is the name argument value.
			Name string
		}
		// Stat holds details about calls to the Stat method.
		Stat []struct {
			// Pth is the pth argument value.
			Pth string
		}
		// TempDir holds details about calls to the TempDir method.
		TempDir []struct {
		}
		// UserHomeDir holds details about calls to the UserHomeDir method.
		UserHomeDir []struct {
		}
		// WriteFile holds details about calls to the WriteFile method.
		WriteFile []struct {
			// Name is the name argument value.
			Name string
			// Data is the data argument value.
			Data []byte
			// Mode is the mode argument value.
			Mode os.FileMode
		}
	}
	lockCreate           sync.RWMutex
	lockExecutable       sync.RWMutex
	lockGetwd            sync.RWMutex
	lockHostname         sync.RWMutex
	lockMkdirAll         sync.RWMutex
	lockOpenFile         sync.RWMutex
	lockReadFileIfExists sync.RWMutex
	lockRemove           sync.RWMutex
	lockStat             sync.RWMutex
	lockTempDir          sync.RWMutex
	lockUserHomeDir      sync.RWMutex
	lockWriteFile        sync.RWMutex
}

// Create calls CreateFunc.
func (mock *OsProxyMock) Create(name string) (*os.File, error) {
	if mock.CreateFunc == nil {
		panic("OsProxyMock.CreateFunc: method is nil but OsProxy.Create was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(name)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedOsProxy.CreateCalls())
func (mock *OsProxyMock) CreateCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Executable calls ExecutableFunc.
func (mock *OsProxyMock) Executable() (string, error) {
	if mock.ExecutableFunc == nil {
		panic("OsProxyMock.ExecutableFunc: method is nil but OsProxy.Executable was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExecutable.Lock()
	mock.calls.Executable = append(mock.calls.Executable, callInfo)
	mock.lockExecutable.Unlock()
	return mock.ExecutableFunc()
}

// ExecutableCalls gets all the calls that were made to Executable.
// Check the length with:
//
//	len(mockedOsProxy.ExecutableCalls())
func (mock *OsProxyMock) ExecutableCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExecutable.RLock()
	calls = mock.calls.Executable
	mock.lockExecutable.RUnlock()
	return calls
}

// Getwd calls GetwdFunc.
func (mock *OsProxyMock) Getwd() (string, error) {
	if mock.GetwdFunc == nil {
		panic("OsProxyMock.GetwdFunc: method is nil but OsProxy.Getwd was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetwd.Lock()
	mock.calls.Getwd = append(mock.calls.Getwd, callInfo)
	mock.lockGetwd.Unlock()
	return mock.GetwdFunc()
}

// GetwdCalls gets all the calls that were made to Getwd.
// Check the length with:
//
//	len(mockedOsProxy.GetwdCalls())
func (mock *OsProxyMock) GetwdCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetwd.RLock()
	calls = mock.calls.Getwd
	mock.lockGetwd.RUnlock()
	return calls
}

// Hostname calls HostnameFunc.
func (mock *OsProxyMock) Hostname() (string, error) {
	if mock.HostnameFunc == nil {
		panic("OsProxyMock.HostnameFunc: method is nil but OsProxy.Hostname was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHostname.Lock()
	mock.calls.Hostname = append(mock.calls.Hostname, callInfo)
	mock.lockHostname.Unlock()
	return mock.HostnameFunc()
}

// HostnameCalls gets all the calls that were made to Hostname.
// Check the length with:
//
//	len(mockedOsProxy.HostnameCalls())
func (mock *OsProxyMock) HostnameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHostname.RLock()
	calls = mock.calls.Hostname
	mock.lockHostname.RUnlock()
	return calls
}

// MkdirAll calls MkdirAllFunc.
func (mock *OsProxyMock) MkdirAll(name string, mode os.FileMode) error {
	if mock.MkdirAllFunc == nil {
		panic("OsProxyMock.MkdirAllFunc: method is nil but OsProxy.MkdirAll was just called")
	}
	callInfo := struct {
		Name string
		Mode os.FileMode
	}{
		Name: name,
		Mode: mode,
	}
	mock.lockMkdirAll.Lock()
	mock.calls.MkdirAll = append(mock.calls.MkdirAll, callInfo)
	mock.lockMkdirAll.Unlock()
	return mock.MkdirAllFunc(name, mode)
}

// MkdirAllCalls gets all the calls that were made to MkdirAll.
// Check the length with:
//
//	len(mockedOsProxy.MkdirAllCalls())
func (mock *OsProxyMock) MkdirAllCalls() []struct {
	Name string
	Mode os.FileMode
} {
	var calls []struct {
		Name string
		Mode os.FileMode
	}
	mock.lockMkdirAll.RLock()
	calls = mock.calls.MkdirAll
	mock.lockMkdirAll.RUnlock()
	return calls
}

// OpenFile calls OpenFileFunc.
func (mock *OsProxyMock) OpenFile(name string, flag int, perm os.FileMode) (*os.File, error) {
	if mock.OpenFileFunc == nil {
		panic("OsProxyMock.OpenFileFunc: method is nil but OsProxy.OpenFile was just called")
	}
	callInfo := struct {
		Name string
		Flag int
		Perm os.FileMode
	}{
		Name: name,
		Flag: flag,
		Perm: perm,
	}
	mock.lockOpenFile.Lock()
	mock.calls.OpenFile = append(mock.calls.OpenFile, callInfo)
	mock.lockOpenFile.Unlock()
	return mock.OpenFileFunc(name, flag, perm)
}

// OpenFileCalls gets all the calls that were made to OpenFile.
// Check the length with:
//
//	len(mockedOsProxy.OpenFileCalls())
func (mock *OsProxyMock) OpenFileCalls() []struct {
	Name string
	Flag int
	Perm os.FileMode
} {
	var calls []struct {
		Name string
		Flag int
		Perm os.FileMode
	}
	mock.lockOpenFile.RLock()
	calls = mock.calls.OpenFile
	mock.lockOpenFile.RUnlock()
	return calls
}

// ReadFileIfExists calls ReadFileIfExistsFunc.
func (mock *OsProxyMock) ReadFileIfExists(name string) (string, bool, error) {
	if mock.ReadFileIfExistsFunc == nil {
		panic("OsProxyMock.ReadFileIfExistsFunc: method is nil but OsProxy.ReadFileIfExists was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockReadFileIfExists.Lock()
	mock.calls.ReadFileIfExists = append(mock.calls.ReadFileIfExists, callInfo)
	mock.lockReadFileIfExists.Unlock()
	return mock.ReadFileIfExistsFunc(name)
}

// ReadFileIfExistsCalls gets all the calls that were made to ReadFileIfExists.
// Check the length with:
//
//	len(mockedOsProxy.ReadFileIfExistsCalls())
func (mock *OsProxyMock) ReadFileIfExistsCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockReadFileIfExists.RLock()
	calls = mock.calls.ReadFileIfExists
	mock.lockReadFileIfExists.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *OsProxyMock) Remove(name string) error {
	if mock.RemoveFunc == nil {
		panic("OsProxyMock.RemoveFunc: method is nil but OsProxy.Remove was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	return mock.RemoveFunc(name)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedOsProxy.RemoveCalls())
func (mock *OsProxyMock) RemoveCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Stat calls StatFunc.
func (mock *OsProxyMock) Stat(pth string) (os.FileInfo, error) {
	if mock.StatFunc == nil {
		panic("OsProxyMock.StatFunc: method is nil but OsProxy.Stat was just called")
	}
	callInfo := struct {
		Pth string
	}{
		Pth: pth,
	}
	mock.lockStat.Lock()
	mock.calls.Stat = append(mock.calls.Stat, callInfo)
	mock.lockStat.Unlock()
	return mock.StatFunc(pth)
}

// StatCalls gets all the calls that were made to Stat.
// Check the length with:
//
//	len(mockedOsProxy.StatCalls())
func (mock *OsProxyMock) StatCalls() []struct {
	Pth string
} {
	var calls []struct {
		Pth string
	}
	mock.lockStat.RLock()
	calls = mock.calls.Stat
	mock.lockStat.RUnlock()
	return calls
}

// TempDir calls TempDirFunc.
func (mock *OsProxyMock) TempDir() string {
	if mock.TempDirFunc == nil {
		panic("OsProxyMock.TempDirFunc: method is nil but OsProxy.TempDir was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTempDir.Lock()
	mock.calls.TempDir = append(mock.calls.TempDir, callInfo)
	mock.lockTempDir.Unlock()
	return mock.TempDirFunc()
}

// TempDirCalls gets all the calls that were made to TempDir.
// Check the length with:
//
//	len(mockedOsProxy.TempDirCalls())
func (mock *OsProxyMock) TempDirCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTempDir.RLock()
	calls = mock.calls.TempDir
	mock.lockTempDir.RUnlock()
	return calls
}

// UserHomeDir calls UserHomeDirFunc.
func (mock *OsProxyMock) UserHomeDir() (string, error) {
	if mock.UserHomeDirFunc == nil {
		panic("OsProxyMock.UserHomeDirFunc: method is nil but OsProxy.UserHomeDir was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUserHomeDir.Lock()
	mock.calls.UserHomeDir = append(mock.calls.UserHomeDir, callInfo)
	mock.lockUserHomeDir.Unlock()
	return mock.UserHomeDirFunc()
}

// UserHomeDirCalls gets all the calls that were made to UserHomeDir.
// Check the length with:
//
//	len(mockedOsProxy.UserHomeDirCalls())
func (mock *OsProxyMock) UserHomeDirCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUserHomeDir.RLock()
	calls = mock.calls.UserHomeDir
	mock.lockUserHomeDir.RUnlock()
	return calls
}

// WriteFile calls WriteFileFunc.
func (mock *OsProxyMock) WriteFile(name string, data []byte, mode os.FileMode) error {
	if mock.WriteFileFunc == nil {
		panic("OsProxyMock.WriteFileFunc: method is nil but OsProxy.WriteFile was just called")
	}
	callInfo := struct {
		Name string
		Data []byte
		Mode os.FileMode
	}{
		Name: name,
		Data: data,
		Mode: mode,
	}
	mock.lockWriteFile.Lock()
	mock.calls.WriteFile = append(mock.calls.WriteFile, callInfo)
	mock.lockWriteFile.Unlock()
	return mock.WriteFileFunc(name, data, mode)
}

// WriteFileCalls gets all the calls that were made to WriteFile.
// Check the length with:
//
//	len(mockedOsProxy.WriteFileCalls())
func (mock *OsProxyMock) WriteFileCalls() []struct {
	Name string
	Data []byte
	Mode os.FileMode
} {
	var calls []struct {
		Name string
		Data []byte
		Mode os.FileMode
	}
	mock.lockWriteFile.RLock()
	calls = mock.calls.WriteFile
	mock.lockWriteFile.RUnlock()
	return calls
}
