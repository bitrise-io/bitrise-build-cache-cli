// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/bitrise-io/bitrise-build-cache-cli/internal/utils"
	"sync"
)

// Ensure, that DecoderMock does implement utils.Decoder.
// If this is not the case, regenerate this file with moq.
var _ utils.Decoder = &DecoderMock{}

// DecoderMock is a mock implementation of utils.Decoder.
//
//	func TestSomethingThatUsesDecoder(t *testing.T) {
//
//		// make and configure a mocked utils.Decoder
//		mockedDecoder := &DecoderMock{
//			DecodeFunc: func(data any) error {
//				panic("mock out the Decode method")
//			},
//		}
//
//		// use mockedDecoder in code that requires utils.Decoder
//		// and then make assertions.
//
//	}
type DecoderMock struct {
	// DecodeFunc mocks the Decode method.
	DecodeFunc func(data any) error

	// calls tracks calls to the methods.
	calls struct {
		// Decode holds details about calls to the Decode method.
		Decode []struct {
			// Data is the data argument value.
			Data any
		}
	}
	lockDecode sync.RWMutex
}

// Decode calls DecodeFunc.
func (mock *DecoderMock) Decode(data any) error {
	if mock.DecodeFunc == nil {
		panic("DecoderMock.DecodeFunc: method is nil but Decoder.Decode was just called")
	}
	callInfo := struct {
		Data any
	}{
		Data: data,
	}
	mock.lockDecode.Lock()
	mock.calls.Decode = append(mock.calls.Decode, callInfo)
	mock.lockDecode.Unlock()
	return mock.DecodeFunc(data)
}

// DecodeCalls gets all the calls that were made to Decode.
// Check the length with:
//
//	len(mockedDecoder.DecodeCalls())
func (mock *DecoderMock) DecodeCalls() []struct {
	Data any
} {
	var calls []struct {
		Data any
	}
	mock.lockDecode.RLock()
	calls = mock.calls.Decode
	mock.lockDecode.RUnlock()
	return calls
}
