// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/bitrise-io/bitrise-build-cache-cli/internal/xcelerate/proxy"
	"github.com/bitrise-io/go-utils/v2/log"
	"io"
	"sync"
)

// Ensure, that ClientMock does implement proxy.Client.
// If this is not the case, regenerate this file with moq.
var _ proxy.Client = &ClientMock{}

// ClientMock is a mock implementation of proxy.Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked proxy.Client
//		mockedClient := &ClientMock{
//			ChangeSessionFunc: func(invocationID string, appSlug string, buildSlug string, stepSlug string)  {
//				panic("mock out the ChangeSession method")
//			},
//			DownloadStreamFunc: func(ctx context.Context, writer io.Writer, key string) error {
//				panic("mock out the DownloadStream method")
//			},
//			GetCapabilitiesWithRetryFunc: func(ctx context.Context) error {
//				panic("mock out the GetCapabilitiesWithRetry method")
//			},
//			SetLoggerFunc: func(logger log.Logger)  {
//				panic("mock out the SetLogger method")
//			},
//			UploadStreamToBuildCacheFunc: func(ctx context.Context, reader io.Reader, key string, size int64) error {
//				panic("mock out the UploadStreamToBuildCache method")
//			},
//		}
//
//		// use mockedClient in code that requires proxy.Client
//		// and then make assertions.
//
//	}
type ClientMock struct {
	// ChangeSessionFunc mocks the ChangeSession method.
	ChangeSessionFunc func(invocationID string, appSlug string, buildSlug string, stepSlug string)

	// DownloadStreamFunc mocks the DownloadStream method.
	DownloadStreamFunc func(ctx context.Context, writer io.Writer, key string) error

	// GetCapabilitiesWithRetryFunc mocks the GetCapabilitiesWithRetry method.
	GetCapabilitiesWithRetryFunc func(ctx context.Context) error

	// SetLoggerFunc mocks the SetLogger method.
	SetLoggerFunc func(logger log.Logger)

	// UploadStreamToBuildCacheFunc mocks the UploadStreamToBuildCache method.
	UploadStreamToBuildCacheFunc func(ctx context.Context, reader io.Reader, key string, size int64) error

	// calls tracks calls to the methods.
	calls struct {
		// ChangeSession holds details about calls to the ChangeSession method.
		ChangeSession []struct {
			// InvocationID is the invocationID argument value.
			InvocationID string
			// AppSlug is the appSlug argument value.
			AppSlug string
			// BuildSlug is the buildSlug argument value.
			BuildSlug string
			// StepSlug is the stepSlug argument value.
			StepSlug string
		}
		// DownloadStream holds details about calls to the DownloadStream method.
		DownloadStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Writer is the writer argument value.
			Writer io.Writer
			// Key is the key argument value.
			Key string
		}
		// GetCapabilitiesWithRetry holds details about calls to the GetCapabilitiesWithRetry method.
		GetCapabilitiesWithRetry []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SetLogger holds details about calls to the SetLogger method.
		SetLogger []struct {
			// Logger is the logger argument value.
			Logger log.Logger
		}
		// UploadStreamToBuildCache holds details about calls to the UploadStreamToBuildCache method.
		UploadStreamToBuildCache []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Reader is the reader argument value.
			Reader io.Reader
			// Key is the key argument value.
			Key string
			// Size is the size argument value.
			Size int64
		}
	}
	lockChangeSession            sync.RWMutex
	lockDownloadStream           sync.RWMutex
	lockGetCapabilitiesWithRetry sync.RWMutex
	lockSetLogger                sync.RWMutex
	lockUploadStreamToBuildCache sync.RWMutex
}

// ChangeSession calls ChangeSessionFunc.
func (mock *ClientMock) ChangeSession(invocationID string, appSlug string, buildSlug string, stepSlug string) {
	callInfo := struct {
		InvocationID string
		AppSlug      string
		BuildSlug    string
		StepSlug     string
	}{
		InvocationID: invocationID,
		AppSlug:      appSlug,
		BuildSlug:    buildSlug,
		StepSlug:     stepSlug,
	}
	mock.lockChangeSession.Lock()
	mock.calls.ChangeSession = append(mock.calls.ChangeSession, callInfo)
	mock.lockChangeSession.Unlock()
	if mock.ChangeSessionFunc == nil {
		return
	}
	mock.ChangeSessionFunc(invocationID, appSlug, buildSlug, stepSlug)
}

// ChangeSessionCalls gets all the calls that were made to ChangeSession.
// Check the length with:
//
//	len(mockedClient.ChangeSessionCalls())
func (mock *ClientMock) ChangeSessionCalls() []struct {
	InvocationID string
	AppSlug      string
	BuildSlug    string
	StepSlug     string
} {
	var calls []struct {
		InvocationID string
		AppSlug      string
		BuildSlug    string
		StepSlug     string
	}
	mock.lockChangeSession.RLock()
	calls = mock.calls.ChangeSession
	mock.lockChangeSession.RUnlock()
	return calls
}

// DownloadStream calls DownloadStreamFunc.
func (mock *ClientMock) DownloadStream(ctx context.Context, writer io.Writer, key string) error {
	callInfo := struct {
		Ctx    context.Context
		Writer io.Writer
		Key    string
	}{
		Ctx:    ctx,
		Writer: writer,
		Key:    key,
	}
	mock.lockDownloadStream.Lock()
	mock.calls.DownloadStream = append(mock.calls.DownloadStream, callInfo)
	mock.lockDownloadStream.Unlock()
	if mock.DownloadStreamFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DownloadStreamFunc(ctx, writer, key)
}

// DownloadStreamCalls gets all the calls that were made to DownloadStream.
// Check the length with:
//
//	len(mockedClient.DownloadStreamCalls())
func (mock *ClientMock) DownloadStreamCalls() []struct {
	Ctx    context.Context
	Writer io.Writer
	Key    string
} {
	var calls []struct {
		Ctx    context.Context
		Writer io.Writer
		Key    string
	}
	mock.lockDownloadStream.RLock()
	calls = mock.calls.DownloadStream
	mock.lockDownloadStream.RUnlock()
	return calls
}

// GetCapabilitiesWithRetry calls GetCapabilitiesWithRetryFunc.
func (mock *ClientMock) GetCapabilitiesWithRetry(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetCapabilitiesWithRetry.Lock()
	mock.calls.GetCapabilitiesWithRetry = append(mock.calls.GetCapabilitiesWithRetry, callInfo)
	mock.lockGetCapabilitiesWithRetry.Unlock()
	if mock.GetCapabilitiesWithRetryFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.GetCapabilitiesWithRetryFunc(ctx)
}

// GetCapabilitiesWithRetryCalls gets all the calls that were made to GetCapabilitiesWithRetry.
// Check the length with:
//
//	len(mockedClient.GetCapabilitiesWithRetryCalls())
func (mock *ClientMock) GetCapabilitiesWithRetryCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetCapabilitiesWithRetry.RLock()
	calls = mock.calls.GetCapabilitiesWithRetry
	mock.lockGetCapabilitiesWithRetry.RUnlock()
	return calls
}

// SetLogger calls SetLoggerFunc.
func (mock *ClientMock) SetLogger(logger log.Logger) {
	callInfo := struct {
		Logger log.Logger
	}{
		Logger: logger,
	}
	mock.lockSetLogger.Lock()
	mock.calls.SetLogger = append(mock.calls.SetLogger, callInfo)
	mock.lockSetLogger.Unlock()
	if mock.SetLoggerFunc == nil {
		return
	}
	mock.SetLoggerFunc(logger)
}

// SetLoggerCalls gets all the calls that were made to SetLogger.
// Check the length with:
//
//	len(mockedClient.SetLoggerCalls())
func (mock *ClientMock) SetLoggerCalls() []struct {
	Logger log.Logger
} {
	var calls []struct {
		Logger log.Logger
	}
	mock.lockSetLogger.RLock()
	calls = mock.calls.SetLogger
	mock.lockSetLogger.RUnlock()
	return calls
}

// UploadStreamToBuildCache calls UploadStreamToBuildCacheFunc.
func (mock *ClientMock) UploadStreamToBuildCache(ctx context.Context, reader io.Reader, key string, size int64) error {
	callInfo := struct {
		Ctx    context.Context
		Reader io.Reader
		Key    string
		Size   int64
	}{
		Ctx:    ctx,
		Reader: reader,
		Key:    key,
		Size:   size,
	}
	mock.lockUploadStreamToBuildCache.Lock()
	mock.calls.UploadStreamToBuildCache = append(mock.calls.UploadStreamToBuildCache, callInfo)
	mock.lockUploadStreamToBuildCache.Unlock()
	if mock.UploadStreamToBuildCacheFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UploadStreamToBuildCacheFunc(ctx, reader, key, size)
}

// UploadStreamToBuildCacheCalls gets all the calls that were made to UploadStreamToBuildCache.
// Check the length with:
//
//	len(mockedClient.UploadStreamToBuildCacheCalls())
func (mock *ClientMock) UploadStreamToBuildCacheCalls() []struct {
	Ctx    context.Context
	Reader io.Reader
	Key    string
	Size   int64
} {
	var calls []struct {
		Ctx    context.Context
		Reader io.Reader
		Key    string
		Size   int64
	}
	mock.lockUploadStreamToBuildCache.RLock()
	calls = mock.calls.UploadStreamToBuildCache
	mock.lockUploadStreamToBuildCache.RUnlock()
	return calls
}
