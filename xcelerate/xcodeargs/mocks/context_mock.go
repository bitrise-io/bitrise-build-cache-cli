// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/bitrise-io/bitrise-build-cache-cli/xcelerate/xcodeargs"
	"sync"
	"time"
)

// Ensure, that ContextMock does implement xcodeargs.Context.
// If this is not the case, regenerate this file with moq.
var _ xcodeargs.Context = &ContextMock{}

// ContextMock is a mock implementation of xcodeargs.Context.
//
//	func TestSomethingThatUsesContext(t *testing.T) {
//
//		// make and configure a mocked xcodeargs.Context
//		mockedContext := &ContextMock{
//			DeadlineFunc: func() (time.Time, bool) {
//				panic("mock out the Deadline method")
//			},
//			DoneFunc: func() <-chan struct{} {
//				panic("mock out the Done method")
//			},
//			ErrFunc: func() error {
//				panic("mock out the Err method")
//			},
//			ValueFunc: func(key any) any {
//				panic("mock out the Value method")
//			},
//		}
//
//		// use mockedContext in code that requires xcodeargs.Context
//		// and then make assertions.
//
//	}
type ContextMock struct {
	// DeadlineFunc mocks the Deadline method.
	DeadlineFunc func() (time.Time, bool)

	// DoneFunc mocks the Done method.
	DoneFunc func() <-chan struct{}

	// ErrFunc mocks the Err method.
	ErrFunc func() error

	// ValueFunc mocks the Value method.
	ValueFunc func(key any) any

	// calls tracks calls to the methods.
	calls struct {
		// Deadline holds details about calls to the Deadline method.
		Deadline []struct {
		}
		// Done holds details about calls to the Done method.
		Done []struct {
		}
		// Err holds details about calls to the Err method.
		Err []struct {
		}
		// Value holds details about calls to the Value method.
		Value []struct {
			// Key is the key argument value.
			Key any
		}
	}
	lockDeadline sync.RWMutex
	lockDone     sync.RWMutex
	lockErr      sync.RWMutex
	lockValue    sync.RWMutex
}

// Deadline calls DeadlineFunc.
func (mock *ContextMock) Deadline() (time.Time, bool) {
	if mock.DeadlineFunc == nil {
		panic("ContextMock.DeadlineFunc: method is nil but Context.Deadline was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDeadline.Lock()
	mock.calls.Deadline = append(mock.calls.Deadline, callInfo)
	mock.lockDeadline.Unlock()
	return mock.DeadlineFunc()
}

// DeadlineCalls gets all the calls that were made to Deadline.
// Check the length with:
//
//	len(mockedContext.DeadlineCalls())
func (mock *ContextMock) DeadlineCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDeadline.RLock()
	calls = mock.calls.Deadline
	mock.lockDeadline.RUnlock()
	return calls
}

// Done calls DoneFunc.
func (mock *ContextMock) Done() <-chan struct{} {
	if mock.DoneFunc == nil {
		panic("ContextMock.DoneFunc: method is nil but Context.Done was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDone.Lock()
	mock.calls.Done = append(mock.calls.Done, callInfo)
	mock.lockDone.Unlock()
	return mock.DoneFunc()
}

// DoneCalls gets all the calls that were made to Done.
// Check the length with:
//
//	len(mockedContext.DoneCalls())
func (mock *ContextMock) DoneCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDone.RLock()
	calls = mock.calls.Done
	mock.lockDone.RUnlock()
	return calls
}

// Err calls ErrFunc.
func (mock *ContextMock) Err() error {
	if mock.ErrFunc == nil {
		panic("ContextMock.ErrFunc: method is nil but Context.Err was just called")
	}
	callInfo := struct {
	}{}
	mock.lockErr.Lock()
	mock.calls.Err = append(mock.calls.Err, callInfo)
	mock.lockErr.Unlock()
	return mock.ErrFunc()
}

// ErrCalls gets all the calls that were made to Err.
// Check the length with:
//
//	len(mockedContext.ErrCalls())
func (mock *ContextMock) ErrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockErr.RLock()
	calls = mock.calls.Err
	mock.lockErr.RUnlock()
	return calls
}

// Value calls ValueFunc.
func (mock *ContextMock) Value(key any) any {
	if mock.ValueFunc == nil {
		panic("ContextMock.ValueFunc: method is nil but Context.Value was just called")
	}
	callInfo := struct {
		Key any
	}{
		Key: key,
	}
	mock.lockValue.Lock()
	mock.calls.Value = append(mock.calls.Value, callInfo)
	mock.lockValue.Unlock()
	return mock.ValueFunc(key)
}

// ValueCalls gets all the calls that were made to Value.
// Check the length with:
//
//	len(mockedContext.ValueCalls())
func (mock *ContextMock) ValueCalls() []struct {
	Key any
} {
	var calls []struct {
		Key any
	}
	mock.lockValue.RLock()
	calls = mock.calls.Value
	mock.lockValue.RUnlock()
	return calls
}
